\documentclass[a4paper, 10pt, twoside]{article}

\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[spanish, es-ucroman, es-noquoting]{babel}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{float}
\usepackage[noend]{algpseudocode}
\usepackage{enumitem} % Provee macro \setlist
\usepackage[toc, page]{appendix}


%%%%%%%%%% Configuración de Fancyhdr - Inicio %%%%%%%%%%
\pagestyle{fancy}
\thispagestyle{fancy}
\lhead{Trabajo Práctico 3 · Algoritmos y Estructuras de Datos III}
\rhead{Lovisolo · Petaccio · Rossi}
\renewcommand{\footrulewidth}{0.4pt}
\cfoot{\thepage /\pageref{LastPage}}

\fancypagestyle{caratula} {
   \fancyhf{}
   \cfoot{\thepage /\pageref{LastPage}}
   \renewcommand{\headrulewidth}{0pt}
   \renewcommand{\footrulewidth}{0pt}
}
%%%%%%%%%% Configuración de Fancyhdr - Fin %%%%%%%%%%


%%%%%%%%%% Configuración de Algorithmic - Inicio %%%%%%%%%%
% Entorno propio para customizar la presentación del pseudocódigo
\newenvironment{pseudo}[1][]{%
    \vspace{1em}%
    \begin{algorithmic}%
}
{%
    \end{algorithmic}%
    \vspace{1em}%
}


% switch
\algnewcommand\algorithmicswitch{\textbf{switch}}
\algnewcommand\algorithmiccase{\textbf{case}}
\algnewcommand\algorithmicassert{\texttt{assert}}
\algdef{SE}[SWITCH]{Switch}{EndSwitch}[1]{\algorithmicswitch\ #1\ \algorithmicdo}{\algorithmicend\ \algorithmicswitch}%
\algdef{SE}[CASE]{Case}{EndCase}[1]{\algorithmiccase\ #1}{\algorithmicend\ \algorithmiccase}%
\algtext*{EndSwitch}%
\algtext*{EndCase}%




% Valores de verdad
\newcommand{\True}{\textbf{true}}
\newcommand{\False}{\textbf{false}}

% Conectivos lógicos
\newcommand{\PAnd}{\textbf{and} }
\newcommand{\POr}{\textbf{or} }

% Conectivo 'in' para usar así: \ForAll{$foo$ \In $bar$}
\newcommand{\In}{\textbf{in} }

% Conectivo 'to' para usar así: \For{$i = 1$ \In $n$}
\newcommand{\To}{\textbf{to} }

% Control de flujo
\newcommand{\Break}{\State \textbf{break}}
\newcommand{\PReturn}{\State \textbf{return} }

% Complejidades
\newcommand{\Ode}[1]{\hfill $O(#1)$}
%%%%%%%%%% Configuración de Algorithmic - Fin %%%%%%%%%%


%%%%%%%%%% Miscelánea - Inicio %%%%%%%%%%
% Evita que el documento se estire verticalmente para ocupar el espacio vacío
% en cada página.
\raggedbottom

% Deshabilita sangría en la primer línea de un párrafo.
\setlength{\parindent}{0em}

% Separación entre párrafos.
\setlength{\parskip}{0.5em}

% Separación entre elementos de listas.
\setlist{itemsep=0.5em}

% Asigna la traducción de la palabra 'Appendices'.
\renewcommand{\appendixtocname}{Apéndices}
\renewcommand{\appendixpagename}{Apéndices}
%%%%%%%%%% Miscelánea - Fin %%%%%%%%%%


%%%%%%%%%% Gráficos - Inicio %%%%%%%%%%
% Macro para incluir tres gráficos (dentro de una figura) de manera que
% entren todos en una sola página.
\newcommand{\tresgraficos}[3]{
    \newcommand{\separacion}{-2.2em}
    \vspace{\separacion}
    \include{#1}
    \vspace{\separacion}
    \include{#2}
    \vspace{\separacion}
    \include{#3}
}

% Macro para incluir dos gráficos (dentro de una figura) de manera que
% entren todos en una sola página.
\newcommand{\dosgraficos}[2]{
    \newcommand{\separacion}{-2.2em}
    \vspace{\separacion}
    \include{#1}
    \vspace{\separacion}
    \include{#2}
}
%%%%%%%%%% Gráficos - Fin %%%%%%%%%%


\begin{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Carátula                                                                  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\thispagestyle{caratula}

\begin{center}

\includegraphics[height=2cm]{DC.png} 
\hfill
\includegraphics[height=2cm]{UBA.jpg} 

\vspace{2cm}

Departamento de Computación,\\
Facultad de Ciencias Exactas y Naturales,\\
Universidad de Buenos Aires

\vspace{4cm}

\begin{Huge}
Trabajo Práctico 3
\end{Huge}

\vspace{0.5cm}

\begin{Large}
Algoritmos y Estructuras de Datos III
\end{Large}

\vspace{1cm}

Segundo Cuatrimestre de 2013

\vspace{4cm}

\begin{tabular}{|c|c|c|}
\hline
Apellido y Nombre & LU & E-mail\\
\hline
Leandro Lovisolo      & 645/11 & leandro@leandro.me\\
Lautaro José Petaccio & 443/11 & lausuper@gmail.com\\
Lucas Rossi           & 705/11 & lucasrossi20@gmail.com\\
\hline
\end{tabular}

\end{center}

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Índice                                                                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\tableofcontents

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Introducción                                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Introducción}

En el presente trabajo estudiamos tres problemas algorítmicos, proponemos soluciones para los mismos respetando sus requerimientos de complejidad temporal y analizamos empíricamente los tiempos de ejecución de sus implementaciones en lenguaje C++.

La motivación de este trabajo es comparar las cotas temporales obtenidas del análisis teórico con las mediciones de tiempos de ejecución y extraer conclusiones de esta experimentación.

Sin más, presentamos los problemas estudiados a continuación.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Descipcion de situaciones reales                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\section{Descripción de situaciones reales}
\begin{itemize}
\item Se tiene una serie de ciudades donde es posible construir una antena de señal. Las antenas deben poder comunicarse entre si para que el sistema funcione y solo pasa si están lo suficientemente cerca (se tiene una arista para las antenas suficientemente cerca). El algoritmo de CFM podrá determinar una buena distribución de las antenas que cubran la mayor cantidad de ciudades posible y estén conectadas entre si.

\item Una red social podría utilizar este tipo de algoritmos para encontrar posibles nuevas amistades según un grupo de amigos.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Algoritmo exacto                                                          %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\section{Algoritmo exacto}
\subsection{Algoritmo}
Para la implementación del algoritmo exacto utilizamos la técnica de backtracking que puede verse a continuación.

\begin{pseudo}

\State nodo es tupla $<$ adyacentes : conjunto de int, numero : int $>$
\State
\Procedure{parteDelClique}{vector de int \&clique, vector de nodo \&nodos, int nodoActual} $\rightarrow$ bool
	\For{i = 0 To Tamaño(clique) - 1}
		\If{!nodos[clique[i]].adyacentes.Pertenece?(nodoActual)}								\Ode{log n}
			\State return false
		\EndIf
	\EndFor
	\State return true
\EndProcedure

\State
\Procedure{frontera}{vector de nodo \&nodos, vector de int \&clique} $\rightarrow$ int 
	\State size : int $\leftarrow$ 0
	\For{i = 0 To Tamaño(clique) - 1}
		\State size $\leftarrow$ size + Tamaño(nodos[clique[i]].adyacentes)				\Ode{1}
	\EndFor
	\State size $\leftarrow$ size - (Tamaño(clique)-1) * Tamaño(clique)				\Ode{1}
	\State return size;
\EndProcedure

\State
\Procedure{fronteraMaxima}{vector de nodo \&nodos, vector de int \&clique, unsigned pos} $\rightarrow$ tupla $<$ int , vector de int $>$

	\If{pos == Tamaño(nodos)} return tupla $<$ 0, vector de int vacio $>$ \EndIf
	\State fronteraMax : int $\leftarrow$ 0; \Comment{Guarda la frontera máxima}
	\State vector de int *maxClique $\leftarrow$ 0; \Comment{Guarda el clique máximo}
	\For{i = pos To Tamaño(nodos)}
		\If{parteDelClique(clique, nodos, i)}															\Ode{N*log N}
			\State vector de int cliqueTmp $\leftarrow$ Copia(clique)						\Ode{N}
			\State cliqueTmp.Agregar(i)																			\Ode{1}
			\State fronteraRec : tupla $<$ int, vector de int $>$ $\leftarrow$ fronteraMaxima(nodos, cliqueTmp, i + 1)
			\State tmpFrontera : int $\leftarrow$ frontera(nodos, cliqueTmp)		\Ode{N}
			\If{max(tmpFrontera, fronteraRec.first) $>$ fronteraMax}						\Ode{1}
				\State fronteraMax $\leftarrow$ max(tmpFrontera, fronteraRec.first)	\Ode{1}
				\If{maxClique != 0} delete maxClique \EndIf												\Ode{1}
				\If{tmpFrontera > fronteraRec.first}															\Ode{1}
					\State maxClique : vector de int $\leftarrow$ Copia(cliqueTmp)		\Ode{N}
				\Else
					\State maxClique : vector de int $\leftarrow$ Copia(fronteraRec.second) \Ode{N}
				\EndIf
			\EndIf
		\EndIf
	\EndFor
	\If{maxClique == 0}																								\Ode{1}
		\State return tupla $<$ fronteraMax, vector de int vacio $>$					\Ode{1}
	\Else
		 \State res : vector de int $\leftarrow$ Copia(*maxClique)						\Ode{N}
		\State delete maxClique																					\Ode{1}
		\State return tupla $<$ fronteraMax, res $>$
	\EndIf

\EndProcedure
\end{pseudo}

\subsection{Complejidad}

\subsection{Pérformance}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Heurística contructiva golosa                                             %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\section{Heurística contructiva golosa}
\subsection{Algoritmo}
La implementación realizada para resolver el problema con una heurística golosa realiza los siguientes procedimientos:
\begin{enumerate}
\item Elijo el nodo de grado máximo que sera la clique de tamaño 1 donde empezara el algoritmo. Marco como actual el nodo inicial.
\item Para el nodo actual, recorro sus adyacentes y calculo cuanto aportaría a la frontera agregar ese adyacente si es posible agregarlo al clique.
\item Agrego al clique el máximo de todos los adyacentes vistos y lo elijo como el actual.
\item Vuelvo al punto 2 hasta que no haya adyacente que mejore la frontera.
\end{enumerate}

A continuación presentamos el pseudocódigo:

\begin{pseudo}
\Procedure{enElclique}{vector de int \&clique, int pos} $\rightarrow$ bool
	\For{i = 0 To Tamaño(clique) - 1}
		\If{clique[i] == pos}																									\Ode{1}
			\State return true
		\EndIf
	\EndFor
	\State return false
\EndProcedure
\State
\Procedure{golosa}{vector de nodo \&nodos} $\leftarrow$ tupla $<$ int, vector de int $>$
	\State actual : int $\leftarrow$ NodoDeMaximaAdyacencia(nodos)									\Ode{N}
	\State frontera : int $\leftarrow$ 0																					\Ode{1}
	\State resultado : vector de int																						\Ode{1}
	\State cambio : cambio $\leftarrow$ true																			\Ode{1}
	\While{cambio == true}
		\State maxFronteraLocal : int $\leftarrow$ 0 \Comment{Guarda la frontera máxima de los adyacentes} \Ode{1}
	 	\State maxAdyacenteLocal : int \Comment{Guarda el índice del adyacente de frontera máxima} \Ode{1}
	 	\State resultado.Agregar(actual); \Comment{Guardo en el resultado el vértice actual} \Ode{1}
	 	\State cambio $\leftarrow$ false;
	 	
	 	\For{it : iterador dameUno(nodos[actual].adyacentes) To último elemento}
	 		\If{parteDelClique(resultado, nodos, it) AND !enElclique(resultado, it)} \Ode{N*log N}
	 			\State nuevaFronteraLocal : int $\leftarrow$ Tamaño(nodos[*it].adyacentes) - Tamaño(resultado) 																													\Ode{1}
	 			\If{nuevaFronteraLocal $>$ maxFronteraLocal}													\Ode{1}
	 				\State maxFronteraLocal $\leftarrow$ nuevaFronteraLocal							\Ode{1}
	 				\State maxAdyacenteLocal = *it																		\Ode{1}
	 				\State cambio = true;																						\Ode{1}
	 			\EndIf
	 		\EndIf
	 	\EndFor
	 	\State actual $\leftarrow$ maxAdyacenteLocal															\Ode{1}
	 	\If{!cambio} break \EndIf																								\Ode{1}
	\EndWhile
 	\For{i = 0 To Tamaño(resultado - 1}
 		\State frontera $\leftarrow$ frontera + Tamaño(nodos[resultado[i]].adyacentes)	\Ode{1}
 	\EndFor
 	\State frontera $\leftarrow$ frontera - (Tamaño(resultado) - 1) * Tamaño(resultado \Ode{1}
	\State return tupla $<$ frontera, resultado $>$
\EndProcedure

\end{pseudo}

\subsection{Complejidad}
Sea N cantidad de nodos en el grafo.

En la función enElClique se tiene un ciclo de a lo sumo N veces (máximo clique), realizando operaciones O(1), por lo que la función tiene una complejidad de O(N).

En el algoritmo goloso, se cicla hasta que cambio sea igual a true. Como el algoritmo solo puede agregar nodos nuevos al clique, se ciclaran a lo sumo N veces.
Dentro del ciclo del while se tiene un for que recorre todos los adyacentes del nodo que a lo sumo puede tener a todos los nodos del grafo como adyacentes, por lo que se cicla N veces.
La complejidad ambos ciclos es N * N * O(N*log N) $\subset$ O($N^3$ * log N).
Para finalizar, tiene un for que cicla a lo sumo N veces realizando operaciones O(1).
La complejidad final del algoritmo es O(N) + O($N^3$ * log N) = O($N^3$ * log N).

\subsection{Análisis de eficacia}

\subsection{Performance}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Heurística de búsqueda local                                              %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\section{Heurística de búsqueda local}
\subsection{Algoritmo}

\begin{pseudo}

\State \textbf{operacion} es enum {AGREGAR, ELIMINAR, INTERCAMBIAR}
\State \textbf{indice\_nodo} es int
\State \textbf{nodo} es tupla $<$ indice\_nodo indice, conjuto de indice\_nodo adyacentes$>$
\State \textbf{cmf} es par$<$int, vector de indice\_nodo$>$

\State
\Procedure{local}{vector de nodo nodos, vector de int cliqueInicial} $\rightarrow$ cmf
	
	\State operacion op 																		\Ode{1}
	\State indice\_nodo nodoAAgregar															\Ode{1}
	\State indice\_nodo nodoAEliminar															\Ode{1}
	\State par$<$indice\_nodo, indice\_nodo$>$ nodosAIntercambiar								\Ode{1}
	\State int aporte $\leftarrow$ 0															\Ode{1}

	\State
	\State \textbf{Operación Agregar}
	\State
	\State \textbf{Operación Intercambiar}
	\State
	\State \textbf{Operación Eliminar}
	\State

	\If{aporte == 0} break \EndIf																\Ode{1}

  	\Switch{$op$}
	    \Case{AGREGAR}
		    \State indices\_nodos(solucion).push\_back(nodoAAgregar)
		    \State break
	    \EndCase

	    \Case{ELIMINAR}
		    \State indices\_nodos(solucion).erase(
		    \State indices\_nodos(solucion).begin() + nodoAEliminar)
		    \State break
	    \EndCase

	   	\Case{INTERCAMBIAR}
		    \State indices\_nodos(solucion)[nodosAIntercambiar.first] = nodosAIntercambiar.second
	    \EndCase
	\EndSwitch
	\State
	\State frontera(solucion) += aporte
	\State return solucion

\EndProcedure
\State
\State donde \textbf{Operación Agregar} es:
\State
		\For{unsigned: i = 0 To nodos.size}
			\If{!estaEnLaClique(indices\_nodos(solucion), i) \&
			   agregandoSigueSiendoClique(nodos, indices\_nodos(solucion), i)}

				\State int aporteAgregar = nodos[i].adyacentes.size() - 2 * indices\_nodos(solucion).size()

				\If{aporteAgregar $>$ aporte}
					\State op $\leftarrow$ AGREGAR
					\State nodoAAgregar $\leftarrow$ i
					\State aporte $\leftarrow$ aporteAgregar
				\EndIf
			\EndIf
		\EndFor

\State
\State donde \textbf{Operación Intercambiar} es:
\State

			\For{unsigned j = 0 To nodos.size()}
				\If{!estaEnLaClique(indices\_nodos(solucion), j) \&
				   intercambiandoSigueSiendoClique(
						   nodos, indices\_nodos(solucion), i, j))}

					\State int aporteJEsimo $\leftarrow$ nodos[j].adyacentes.size() -(indices\_nodos(solucion).size() - 1)

					\State int aporteNeto $\leftarrow$ aporteJEsimo - aporteIEsimo

					\If{aporteNeto $>$ aporte}
						\State aporte $\leftarrow$ aporteNeto
						\State op $\leftarrow$ INTERCAMBIAR
						\State nodosAIntercambiar $\leftarrow$ make\_pair(i, j)
					\EndIf
				\EndIf
			\EndFor		

\State
\State donde \textbf{Operación Eliminar} es:
\State
		\For{unsigned i = 0 To indices\_nodos(solucion).size}
			\State indice\_nodo iEsimo $\leftarrow$ indices\_nodos(solucion)[i]
			\State int aporteEliminar $\leftarrow$ 2 * (indices\_nodos(solucion).size() - 1) - nodos[iEsimo].adyacentes.size()

			\If{aporteEliminar $>$ aporte}
				\State op $\leftarrow$ ELIMINAR
				\State odoAEliminar $\leftarrow$ i
				\State aporte $\leftarrow$ aporteEliminar
			\EndIf
		\EndFor


\end{pseudo}

\subsection{Complejidad}
\subsection{Análisis de eficacia}
\subsection{Performance}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Heurística de búsqueda Tabú                                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\section{Heurística de búsqueda Tabú}
\subsection{Algoritmo}
\subsection{Complejidad}
\subsection{Análisis de eficacia}
\subsection{Performance}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Experimentación                                                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\section{Experimentación}




\end{document}